---
phase: 03-llm-prompt-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/deduplicator.py
autonomous: true

must_haves:
  truths:
    - "prepare_creditors_for_llm() extracts only sender_name, reference_number, is_representative, and actual_creditor from creditor dicts"
    - "prepare_creditors_for_llm() omits empty/N/A fields to save tokens"
    - "prepare_creditors_for_llm() formats creditors as a numbered list string"
    - "build_dedup_prompt() returns a German-language prompt with few-shot examples, rules, and the creditor list"
    - "build_dedup_prompt() includes creditor count and completeness instruction"
    - "validate_dedup_response() validates JSON structure, index bounds, completeness, and cross-group uniqueness"
    - "DuplicateGroups Pydantic model validates groups field with field_validator for cross-group duplicate check"
  artifacts:
    - path: "app/services/deduplicator.py"
      provides: "prepare_creditors_for_llm, build_dedup_prompt, validate_dedup_response, DuplicateGroups"
      contains: "class DuplicateGroups"
  key_links:
    - from: "prepare_creditors_for_llm"
      to: "build_dedup_prompt"
      via: "formatted creditor string passed as argument"
      pattern: "build_dedup_prompt.*prepare_creditors_for_llm"
    - from: "validate_dedup_response"
      to: "DuplicateGroups"
      via: "Pydantic model_validate_json"
      pattern: "DuplicateGroups.model_validate"
---

<objective>
Create the new minimal-payload prompt infrastructure for creditor deduplication: payload preparation, German-language prompt builder, Pydantic response model, and two-layer validation.

Purpose: Satisfies LLM-01 (minimal input fields), LLM-02 (index array output format), and LLM-03 (token budget) by building the helper functions that Plan 02 will wire into the live `deduplicate_with_llm()` method.

Output: Four new functions/classes added to `app/services/deduplicator.py` in the FastAPI service.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-llm-prompt-optimization/03-CONTEXT.md
@.planning/phases/03-llm-prompt-optimization/03-RESEARCH.md

Source file to modify (FastAPI service — DIFFERENT repo):
@/Users/luka.s/Cursor : Mandanten - Portal/Creditor-process-fastAPI/app/services/deduplicator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add prepare_creditors_for_llm() and build_dedup_prompt()</name>
  <files>/Users/luka.s/Cursor : Mandanten - Portal/Creditor-process-fastAPI/app/services/deduplicator.py</files>
  <action>
Add two module-level functions ABOVE the `CreditorDeduplicator` class in `deduplicator.py`.

**1. `prepare_creditors_for_llm(creditors: List[Dict[str, Any]]) -> str`**

Extract minimal identifying fields from each creditor dict and format as a numbered list string. This satisfies LLM-01.

Logic:
- Iterate creditors with `enumerate` for 0-based indices
- For each creditor, collect only non-empty, non-"N/A" values of:
  - `sender_name` (label: `name`)
  - `reference_number` (label: `ref`)
  - `is_representative` — only include if `True` (label: `is_rep=True`)
  - `actual_creditor` — only include if `is_representative` is True AND value is non-empty/non-"N/A" (label: `actual`)
- Format each creditor as: `{idx}: {key}={value}, {key}={value}`
- If a creditor has NO fields after filtering (all empty/N/A), still include the line with just the index so the LLM knows it exists: `{idx}: (keine Daten)`
- Return the joined lines as a single string with newlines

Example output:
```
0: name=Deutsche Bank AG, ref=DB-123
1: name=Vodafone GmbH, ref=VF-456
2: name=Inkasso Meyer GmbH, is_rep=True, actual=Deutsche Bank AG
3: name=Georg Weah
4: (keine Daten)
```

**2. `build_dedup_prompt(creditors_str: str, num_creditors: int) -> str`**

Build a German-language dedup prompt with few-shot examples. This satisfies LLM-02 (index array output contract).

Structure:
- System-level instruction in German: "Du bist ein Experte fuer die Identifizierung von Duplikaten in deutschen Glaeubigerlistennn."
- AUFGABE: Analyze {num_creditors} creditors and group duplicates
- REGELN (5 rules):
  1. Same reference_number = definite duplicate (even if names differ slightly)
  2. Similar names without reference = probable duplicate (e.g., "Vodafone GmbH" vs "Vodafone Deutschland GmbH")
  3. Truncated names = duplicate (e.g., "Georg We..." vs "Georg Weah")
  4. Representatives (is_rep=True) with actual_creditor = do NOT auto-group with direct creditor entry (different claims possible)
  5. Legal forms (GmbH, AG, e.V., UG) are part of the name but watch for variations
- BEISPIELE: 2 examples
  - Example 1: Reference number match (Vodafone GmbH ref=VF-123 + Vodafone Deutschland GmbH ref=VF-123 + Deutsche Bank AG) -> groups: [[0,1],[2]]
  - Example 2: Truncated name match (Georg Weah + Georg We... + Maria Schmidt ref=MS-001) -> groups: [[0,1],[2]]
- EINGABE: creditor count + creditor list string
- AUSGABE instruction: JSON with ALL {num_creditors} creditors in exactly one group each. Singletons as single-element arrays.

Use double braces `{{` and `}}` in f-string for JSON examples. Keep the prompt under ~500 tokens of boilerplate (the creditor list scales separately).

Do NOT include "Grund:" (reasoning) lines in the examples — output-only examples to minimize tokens.
  </action>
  <verify>
Read the file and confirm:
1. `prepare_creditors_for_llm` exists as a module-level function above the class
2. `build_dedup_prompt` exists as a module-level function above the class
3. Both functions have type hints and docstrings
4. The prompt text is in German
5. The prompt includes exactly 2 few-shot examples
6. The prompt references `num_creditors` for completeness verification
  </verify>
  <done>
Two standalone functions exist in deduplicator.py that extract minimal creditor fields and build a German dedup prompt with few-shot examples and index-array output contract.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DuplicateGroups Pydantic model and validate_dedup_response()</name>
  <files>/Users/luka.s/Cursor : Mandanten - Portal/Creditor-process-fastAPI/app/services/deduplicator.py</files>
  <action>
Add a Pydantic model and a validation function ABOVE the `CreditorDeduplicator` class (after the functions from Task 1).

**1. `DuplicateGroups` Pydantic BaseModel**

```python
from pydantic import BaseModel, Field, field_validator
from typing import List

class DuplicateGroups(BaseModel):
    groups: List[List[int]] = Field(
        description="Each sub-array contains indices of creditors that are duplicates of each other"
    )

    @field_validator('groups')
    @classmethod
    def no_cross_group_duplicates(cls, groups: List[List[int]]) -> List[List[int]]:
        seen = set()
        for group in groups:
            if not group:
                raise ValueError("Empty group not allowed")
            for idx in group:
                if idx < 0:
                    raise ValueError(f"Negative index {idx} not allowed")
                if idx in seen:
                    raise ValueError(f"Index {idx} appears in multiple groups")
                seen.add(idx)
        return groups
```

Add the Pydantic imports at the top of the file (BaseModel, Field, field_validator are needed). Note: `pydantic` is already in requirements.txt.

**2. `validate_dedup_response(response_text: str, num_creditors: int) -> DuplicateGroups`**

Two-layer validation function that returns a validated `DuplicateGroups` instance or raises `ValueError`.

Layer 1 — Schema validation:
- Parse `response_text` as JSON using `json.loads(response_text, strict=False)`
- If the parsed result is a raw list (not a dict), wrap it: `{"groups": parsed_result}`
- Validate with `DuplicateGroups.model_validate(parsed_dict)` — this checks structure + cross-group duplicates via the field_validator

Layer 2 — Semantic validation:
- Check all indices are in range `[0, num_creditors - 1]`
- Check completeness: every index from 0 to num_creditors-1 must appear exactly once
- If any index is out of bounds: raise `ValueError(f"Index {idx} out of bounds (max: {num_creditors - 1})")`
- If any indices are missing: raise `ValueError(f"Missing creditor indices: {sorted(missing)}")`
- If extra indices found: raise `ValueError(f"Unexpected indices: {sorted(extra)}")`

Return the validated `DuplicateGroups` instance on success.

Also add a helper to get the Vertex AI response schema dict for structured output:

**3. `get_dedup_response_schema() -> dict`**

Returns a JSON Schema dict compatible with Vertex AI's `response_schema` parameter:
```python
def get_dedup_response_schema() -> dict:
    return {
        "type": "object",
        "properties": {
            "groups": {
                "type": "array",
                "items": {
                    "type": "array",
                    "items": {"type": "integer"}
                }
            }
        },
        "required": ["groups"]
    }
```

This schema will be passed to Vertex AI's `GenerationConfig(response_mime_type="application/json", response_schema=...)` in Plan 02 to guarantee syntactically valid JSON output from Gemini.
  </action>
  <verify>
Read the file and confirm:
1. `DuplicateGroups` class exists with `groups` field and `field_validator`
2. `validate_dedup_response` function exists with `response_text` and `num_creditors` params
3. `get_dedup_response_schema` function exists and returns the expected dict structure
4. Pydantic imports (BaseModel, Field, field_validator) are at the top of the file
5. The validation function handles both dict and raw list JSON responses
6. Bounds checking, completeness checking, and cross-group duplicate checking are all present
  </verify>
  <done>
DuplicateGroups Pydantic model validates response structure and cross-group uniqueness. validate_dedup_response() performs two-layer validation (schema + semantic). get_dedup_response_schema() provides the Vertex AI response schema dict. All added to deduplicator.py.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify:
1. `deduplicator.py` has 4 new module-level functions/classes: `prepare_creditors_for_llm`, `build_dedup_prompt`, `DuplicateGroups`, `validate_dedup_response`, `get_dedup_response_schema`
2. No existing functions/methods are modified (the `CreditorDeduplicator` class remains unchanged)
3. All new code has type hints and docstrings
4. No new dependencies added (pydantic already in requirements.txt)
5. File still parses as valid Python: `python -c "import ast; ast.parse(open('app/services/deduplicator.py').read())"`
</verification>

<success_criteria>
- LLM-01: `prepare_creditors_for_llm()` extracts only 4 identifying fields per creditor, omitting empty/N/A values
- LLM-02: `build_dedup_prompt()` instructs LLM to return `{"groups": [[0,3,7], [2,5], ...]}` format; `DuplicateGroups` model validates this structure
- LLM-03: Prompt boilerplate stays under ~500 tokens; per-creditor payload is ~5-8 tokens (vs ~100+ with full objects); `get_dedup_response_schema()` enforces structured JSON output
- Validation catches: out-of-bounds indices, missing creditors, duplicate indices across groups, empty groups, negative indices
</success_criteria>

<output>
After completion, create `.planning/phases/03-llm-prompt-optimization/03-01-SUMMARY.md`
</output>
