---
phase: 08-fastapi-pdf-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /tmp/creditor-fastapi/requirements.txt
  - /tmp/creditor-fastapi/app/services/document_processor.py
autonomous: true

must_haves:
  truths:
    - "PDF file bytes are sent to Gemini as Part with application/pdf MIME type"
    - "Password-protected PDFs are rejected with clear error before Gemini call"
    - "PDFs exceeding 50 pages or 10 MB are rejected with clear error"
    - "Corrupted/invalid PDFs are rejected with clear error"
    - "Image processing (JPG/PNG) works identically to before"
    - "Rotation analysis and correction are skipped for PDFs"
  artifacts:
    - path: "/tmp/creditor-fastapi/requirements.txt"
      provides: "pypdf dependency"
      contains: "pypdf"
    - path: "/tmp/creditor-fastapi/app/services/document_processor.py"
      provides: "PDF support in _load_image_as_part and process_document"
      contains: "application/pdf"
  key_links:
    - from: "/tmp/creditor-fastapi/app/services/document_processor.py"
      to: "vertexai.generative_models.Part"
      via: "Part.from_data with application/pdf MIME type"
      pattern: "Part\\.from_data.*application/pdf"
    - from: "/tmp/creditor-fastapi/app/services/document_processor.py"
      to: "pypdf.PdfReader"
      via: "validate_pdf function"
      pattern: "PdfReader.*is_encrypted"
    - from: "/tmp/creditor-fastapi/app/services/document_processor.py"
      to: "process_document pipeline"
      via: "skip rotation for PDFs"
      pattern: "mime_type.*pdf.*rotation|skip.*rotat"
---

<objective>
Add PDF support to the FastAPI document processor so it can accept and process PDF files alongside existing image uploads.

Purpose: This is the core change for Phase 8 (PDF-01, ERR-01, COMPAT-01). FastAPI currently only handles image MIME types in `_load_image_as_part()`. Adding PDF support lets Gemini process multi-page PDF documents natively, which is the foundation for v3 multi-page creditor extraction.

Output: Modified `document_processor.py` with PDF validation and processing, updated `requirements.txt` with pypdf dependency.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-fastapi-pdf-support/08-CONTEXT.md
@.planning/phases/08-fastapi-pdf-support/08-RESEARCH.md
@.planning/research/ARCHITECTURE.md

IMPORTANT: The FastAPI service is in a SEPARATE repo at /tmp/creditor-fastapi/ (cloned from github.com/justLukaBB/Creditor-process-fastAPI, branch: fix/over-aggressive-dedup). All file modifications are in that repo, NOT in the main Mandanten-Portal repo.

Key codebase facts from code review:
- `_load_image_as_part(self, image_path: str)` takes a FILE PATH, reads bytes from disk, determines MIME type from FILE EXTENSION
- `process_document()` pipeline: classify -> rotation -> extract -> verify. Each step calls `_load_image_as_part(image_path)`.
- `_apply_rotation()` uses PIL.Image.open() which CANNOT open PDFs - must skip rotation for PDFs
- The processing router (`routers/processing.py`) downloads files to a temp dir using the original filename (e.g., `document.pdf`), so the .pdf extension IS preserved
- The existing extraction prompt ALREADY supports multi-creditor detection (creditors array in JSON response)
- No changes needed in the processing router, models, or Node.js backend
- FileInfo model already has `mime_type` field but it's not passed to `_load_image_as_part()` (extension-based detection)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pypdf dependency and create PDF validation</name>
  <files>/tmp/creditor-fastapi/requirements.txt, /tmp/creditor-fastapi/app/services/document_processor.py</files>
  <action>
1. Add `pypdf>=5.0.0` to `/tmp/creditor-fastapi/requirements.txt` (after the `pillow` line, in the Image Processing section). Also add a comment: `# PDF validation (page count, encryption detection)`.

2. In `/tmp/creditor-fastapi/app/services/document_processor.py`, add these imports at the top (after the existing imports):
   ```python
   from pypdf import PdfReader
   from io import BytesIO
   ```

3. Add a `_validate_pdf` method to the `DocumentProcessor` class, BEFORE `_load_image_as_part`:
   ```python
   def _validate_pdf(self, pdf_bytes: bytes, max_pages: int = 50, max_size_mb: int = 10) -> int:
       """
       Validate PDF meets processing constraints.

       Args:
           pdf_bytes: Raw PDF file bytes
           max_pages: Maximum allowed page count (default: 50, from CONTEXT.md)
           max_size_mb: Maximum file size in MB (default: 10, from CONTEXT.md)

       Returns:
           Page count of the valid PDF

       Raises:
           ValueError: If PDF is invalid, too large, too many pages, or encrypted
       """
       # Check file size before parsing
       size_mb = len(pdf_bytes) / (1024 * 1024)
       if size_mb > max_size_mb:
           raise ValueError(
               f"PDF size {size_mb:.1f}MB exceeds maximum {max_size_mb}MB"
           )

       # Parse PDF to check encryption and page count
       try:
           reader = PdfReader(BytesIO(pdf_bytes))

           # Check if password protected (MUST reject per CONTEXT.md decision)
           if reader.is_encrypted:
               raise ValueError(
                   "Password-protected PDFs are not supported. "
                   "Please remove password protection and try again."
               )

           # Check page count
           page_count = len(reader.pages)
           if page_count > max_pages:
               raise ValueError(
                   f"PDF has {page_count} pages, maximum {max_pages} pages allowed"
               )

           if page_count == 0:
               raise ValueError("PDF has no pages")

           logger.info(f"PDF validated: {page_count} pages, {size_mb:.1f}MB")
           return page_count

       except ValueError:
           raise  # Re-raise our own validation errors
       except Exception as e:
           raise ValueError(
               f"PDF file is corrupted or invalid: {str(e)}"
           )
   ```

IMPORTANT: Use `ValueError` (not HTTPException) because this is a service layer, not a route handler. The processing pipeline catches exceptions and sets document status to error.
  </action>
  <verify>
  Run `cd /tmp/creditor-fastapi && python -c "from pypdf import PdfReader; print('pypdf OK')"` after `pip install pypdf>=5.0.0`.
  Grep for `_validate_pdf` in document_processor.py to confirm the method exists.
  Grep for `pypdf` in requirements.txt to confirm the dependency is listed.
  </verify>
  <done>
  - `requirements.txt` contains `pypdf>=5.0.0`
  - `_validate_pdf()` method exists in DocumentProcessor class
  - Method validates: file size (10MB), page count (50), encryption, corruption
  - Method returns page count on success, raises ValueError on failure
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend _load_image_as_part for PDFs and update process_document pipeline</name>
  <files>/tmp/creditor-fastapi/app/services/document_processor.py</files>
  <action>
1. **Update `_load_image_as_part()`** to handle PDF files. Add `.pdf` to the mime_types dict:

   In the existing `_load_image_as_part` method, find the `mime_types` dictionary and add:
   ```python
   '.pdf': 'application/pdf'
   ```

   Then, AFTER the mime_type lookup but BEFORE the `return Part.from_data(...)` call, add PDF validation:
   ```python
   # Validate PDF before sending to Gemini
   if mime_type == 'application/pdf':
       self._validate_pdf(image_bytes)

   # Create Part from file bytes (works for both images and PDFs)
   return Part.from_data(image_bytes, mime_type=mime_type)
   ```

   The complete updated method should look like:
   ```python
   def _load_image_as_part(self, image_path: str) -> Part:
       """
       Load an image or PDF file and convert it to a Vertex AI Part.

       Args:
           image_path: Path to the image or PDF file

       Returns:
           Vertex AI Part object containing the file data
       """
       # Read file bytes
       with open(image_path, 'rb') as f:
           file_bytes = f.read()

       # Determine MIME type from extension
       ext = os.path.splitext(image_path)[1].lower()
       mime_types = {
           '.jpg': 'image/jpeg',
           '.jpeg': 'image/jpeg',
           '.png': 'image/png',
           '.gif': 'image/gif',
           '.webp': 'image/webp',
           '.bmp': 'image/bmp',
           '.pdf': 'application/pdf'
       }
       mime_type = mime_types.get(ext, 'image/jpeg')

       # Validate PDF before sending to Gemini
       if mime_type == 'application/pdf':
           page_count = self._validate_pdf(file_bytes)
           logger.info(f"Loading PDF as Gemini Part: {page_count} pages, {len(file_bytes) / 1024 / 1024:.1f}MB")

       # Create Part from file bytes (works for both images and PDFs)
       return Part.from_data(file_bytes, mime_type=mime_type)
   ```

2. **Update `process_document()`** to skip rotation for PDFs. The pipeline currently does:
   - Step 1: Classification (works for PDFs - Gemini handles natively)
   - Step 2: Readability (already disabled/commented out)
   - Step 3: Rotation analysis + correction (BREAKS for PDFs - PIL can't open PDFs)
   - Step 4: Data extraction (works for PDFs)
   - Step 5: Verification (works for PDFs)

   Find the Step 3 block in `process_document()` that does rotation analysis:
   ```python
   # Step 3: Rotation analysis and correction
   logger.info(f"Analyzing rotation: {filename}")
   rotation = self.analyze_rotation(image_path)
   result.rotation = rotation
   self._apply_rotation(image_path, rotation)
   ```

   Replace it with:
   ```python
   # Step 3: Rotation analysis and correction (images only - PDFs don't need rotation)
   is_pdf = os.path.splitext(image_path)[1].lower() == '.pdf'
   if is_pdf:
       logger.info(f"Skipping rotation analysis for PDF: {filename}")
       result.rotation = RotationResult(
           should_rotate=False,
           rotation_angle="0",
           reason="Rotation analysis skipped for PDF documents"
       )
   else:
       logger.info(f"Analyzing rotation: {filename}")
       rotation = self.analyze_rotation(image_path)
       result.rotation = rotation
       self._apply_rotation(image_path, rotation)
   ```

   This preserves exact backward compatibility for images while skipping the PIL-based rotation for PDFs.

3. **Do NOT modify** any of these:
   - The extraction prompt (it already supports multi-creditor detection)
   - The classification prompt (it says "Dokument" not "Bild")
   - The verification prompt (it references "Dokument")
   - The processing router (`routers/processing.py`) - it already handles any file type
   - The models (`models.py`) - they already support creditors array + source_document_id
   - The webhook service - format-agnostic

   WHY: These components are already format-agnostic. Unnecessary changes risk breaking backward compatibility (COMPAT-01).
  </action>
  <verify>
  1. Grep for `'application/pdf'` in document_processor.py to confirm PDF MIME type is in the dict
  2. Grep for `is_pdf` or `\.pdf` in document_processor.py to confirm rotation skip logic exists
  3. Grep for `_validate_pdf` calls in `_load_image_as_part` to confirm validation is wired
  4. Run `cd /tmp/creditor-fastapi && python -c "from app.services.document_processor import DocumentProcessor; print('Import OK')"` to verify no import errors
  5. Verify the image processing path is unchanged: the existing mime_types dict entries for .jpg/.jpeg/.png should be identical to before
  </verify>
  <done>
  - `_load_image_as_part()` handles .pdf extension, maps to 'application/pdf', validates with `_validate_pdf()` before creating Part
  - `process_document()` skips rotation analysis and PIL rotation for PDF files
  - All existing image MIME types (.jpg, .jpeg, .png, .gif, .webp, .bmp) remain unchanged
  - Classification, extraction, and verification prompts remain untouched
  - No changes to processing router, models, or webhook service
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `requirements.txt` contains `pypdf>=5.0.0`
2. `document_processor.py` imports `pypdf` and `BytesIO`
3. `_validate_pdf()` method validates size, pages, encryption, corruption
4. `_load_image_as_part()` has `.pdf` in mime_types dict and calls `_validate_pdf()` for PDFs
5. `process_document()` skips rotation for PDFs
6. Python import check passes: `from app.services.document_processor import DocumentProcessor`
7. No changes to any other files (processing router, models, webhooks, Node.js backend)
</verification>

<success_criteria>
- PDF-01: FastAPI accepts application/pdf MIME type and creates valid Gemini Part
- ERR-01: Corrupted/password-protected/oversized PDFs get clear error messages (ValueError with descriptive text)
- COMPAT-01: Image processing path is completely unchanged (same mime_types entries, same rotation logic, same prompts)
- The existing multi-creditor extraction prompt works for PDFs without modification
- Rotation is skipped for PDFs (PIL cannot open PDFs)
</success_criteria>

<output>
After completion, create `.planning/phases/08-fastapi-pdf-support/08-01-SUMMARY.md`
</output>
