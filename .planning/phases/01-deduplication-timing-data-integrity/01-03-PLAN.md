---
phase: 01-deduplication-timing-data-integrity
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - server/controllers/zendeskWebhookController.js
autonomous: true

must_haves:
  truths:
    - "Payment status decisions wait for dedup to complete if documents were recently processed"
    - "Payment handler reloads client data after dedup completes to get fresh final_creditor_list"
    - "If dedup takes longer than 60 seconds, payment handler proceeds anyway (no infinite hang)"
  artifacts:
    - path: "server/controllers/zendeskWebhookController.js"
      provides: "waitForDedupIfNeeded function before creditor evaluation"
      contains: "waitForDedupIfNeeded"
  key_links:
    - from: "server/controllers/zendeskWebhookController.js"
      to: "server/models/Client.js"
      via: "polling dedup_in_progress flag from MongoDB"
      pattern: "dedup_in_progress"
---

<objective>
Add dedup-completion waiting logic to the payment handler in zendeskWebhookController.js. Before evaluating creditors for manual review routing, check if dedup is in progress and wait for it to complete (with a 60-second timeout).

Purpose: Prevents payment handler from evaluating stale (pre-dedup) creditor data (DDP-02). Without this, a payment webhook arriving during dedup would see the old creditor list and potentially auto-approve a case that has creditors needing manual review.
Output: Modified zendeskWebhookController.js with waitForDedupIfNeeded function that blocks before the creditorNeedsManualReview evaluation.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-deduplication-timing-data-integrity/01-CONTEXT.md
@.planning/phases/01-deduplication-timing-data-integrity/01-RESEARCH.md

Key source file to read before editing:
@server/controllers/zendeskWebhookController.js

Dependency from Plan 01-01:
Plan 01-01 adds `dedup_in_progress`, `dedup_started_at`, `dedup_completed_at` fields to Client schema and sets them atomically in aiDedupScheduler.js. This plan reads those fields.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add waitForDedupIfNeeded to payment handler</name>
  <files>server/controllers/zendeskWebhookController.js</files>
  <action>
Read the file fully to understand its structure. The payment handler is the `handlePaymentConfirmed` or equivalent method in the `ZendeskWebhookController` class.

**Step 1: Add the waitForDedupIfNeeded helper function.**

Add this function inside the class or as a module-level helper (wherever the class methods can access it). If the controller is a class, add it as a method. If it's an object with methods, add it as a standalone async function near the top of the file, after the requires:

```javascript
/**
 * Wait for dedup to complete if documents were recently processed.
 * Prevents payment status decisions on stale (pre-dedup) creditor data.
 *
 * @param {Object} client - Mongoose client document
 * @param {Object} Client - Mongoose Client model (for fresh queries)
 * @returns {Object} - Fresh client document (reloaded if dedup was waited for)
 */
async function waitForDedupIfNeeded(client, ClientModel) {
  // Only wait if documents were recently processed (within last 5 minutes)
  const recentWindow = 5 * 60 * 1000; // 5 minutes
  const recentlyProcessed = client.all_documents_processed_at &&
    (Date.now() - new Date(client.all_documents_processed_at).getTime()) < recentWindow;

  if (!recentlyProcessed || !client.dedup_in_progress) {
    return client;
  }

  console.log(`[payment-handler] Dedup in progress for ${client.aktenzeichen}, waiting for completion...`);

  const maxWait = 60000; // 60 seconds max wait
  const pollInterval = 2000; // Poll every 2 seconds
  const startWait = Date.now();

  while (Date.now() - startWait < maxWait) {
    await new Promise(resolve => setTimeout(resolve, pollInterval));

    // Reload client from DB to check dedup_in_progress
    const fresh = await ClientModel.findById(client._id).lean(false);
    if (!fresh) {
      console.error(`[payment-handler] Client ${client.aktenzeichen} not found during dedup wait`);
      return client;
    }

    if (!fresh.dedup_in_progress) {
      console.log(`[payment-handler] Dedup completed for ${client.aktenzeichen} after ${Date.now() - startWait}ms`);
      return fresh;
    }
  }

  console.warn(`[payment-handler] Dedup wait timeout (60s) for ${client.aktenzeichen}, proceeding with current data`);
  // Reload one final time to get latest data even if dedup is stuck
  const finalClient = await ClientModel.findById(client._id).lean(false);
  return finalClient || client;
}
```

**Step 2: Call waitForDedupIfNeeded before the creditor evaluation block.**

Find the section where the payment handler evaluates creditors. Look for the block around line 448-450 that sets up `creditors`:

```javascript
const documents = client.documents || [];
const creditorDocs = documents.filter((d) => d.is_creditor_document === true);
const creditors = client.final_creditor_list || [];
```

BEFORE these lines (but after `client` is loaded), add:

```javascript
// Wait for dedup to complete if documents were recently processed
// This prevents evaluating stale creditor data before dedup merges
client = await waitForDedupIfNeeded(client, this.Client || Client);
```

Note: The exact way to access the Client model depends on how the controller is structured. If it's a class with `this.Client`, use that. If the Client model is available in the closure (from the factory function or imports), use that reference. Read the file to determine which pattern applies.

The `Client` model is likely available from the module's requires (look for `require('../models/Client')` at the top of the file or in the class constructor).

**Step 3: Ensure the Client model is accessible.**

Check if `Client` model is already imported/available in the controller. If the controller is a class that receives `Client` in its constructor, use `this.Client`. If it needs to be imported, add at the top of the file:

```javascript
const Client = require('../models/Client');
```

Only add this if not already available through the class constructor or factory injection.
  </action>
  <verify>
1. Read `server/controllers/zendeskWebhookController.js` and confirm:
   - `waitForDedupIfNeeded` function exists with 60-second timeout
   - Function is called before the creditor evaluation block (before `const creditors = client.final_creditor_list`)
   - Client model is accessible for the MongoDB query
2. Grep for `waitForDedupIfNeeded` in the file — should appear as both definition and call
3. Grep for `dedup_in_progress` in the file — should appear in the wait function
4. Run `node -e "require('./server/controllers/zendeskWebhookController')"` — no syntax errors
  </verify>
  <done>
Payment handler checks dedup_in_progress before evaluating creditors. If documents were recently processed (within 5 minutes) and dedup is running, it polls every 2 seconds for up to 60 seconds. After dedup completes (or timeout), it reloads fresh client data to get the post-dedup final_creditor_list. This ensures payment status decisions are never made on stale pre-dedup data.
  </done>
</task>

</tasks>

<verification>
After task completes:

1. **Wait logic present:** Grep for `waitForDedupIfNeeded` in zendeskWebhookController.js — function defined and called
2. **Timeout exists:** The function has a 60-second max wait to prevent infinite hanging
3. **Fresh data loaded:** After waiting, client is reloaded from MongoDB via `findById`
4. **No hang on non-dedup cases:** If `dedup_in_progress` is false or documents weren't recently processed, function returns immediately
5. **Graceful timeout:** If dedup takes >60s, handler proceeds with latest available data (no crash)
6. **No import errors:** File requires cleanly
</verification>

<success_criteria>
- Payment handler calls waitForDedupIfNeeded before evaluating creditors
- If dedup_in_progress is true and documents were recently processed, handler waits up to 60 seconds
- After dedup completes, handler uses fresh client data from MongoDB
- Timeout prevents infinite blocking — handler proceeds after 60 seconds regardless
- Cases where dedup is not running pass through immediately (no unnecessary delay)
</success_criteria>

<output>
After completion, create `.planning/phases/01-deduplication-timing-data-integrity/01-03-SUMMARY.md`
</output>
