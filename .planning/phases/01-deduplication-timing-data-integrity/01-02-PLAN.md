---
phase: 01-deduplication-timing-data-integrity
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - server/services/aiDedupScheduler.js
  - server/controllers/adminClientCreditorController.js
autonomous: true

must_haves:
  truths:
    - "Creditors with needs_manual_review=true retain that flag after dedup runs"
    - "Existing review_reasons arrays are preserved when final_creditor_list is overwritten by dedup"
    - "Manually reviewed creditor state (reviewed_at, reviewed_by, review_action) survives dedup merge"
    - "Both the periodic scheduler dedup and admin-triggered dedup preserve review flags"
  artifacts:
    - path: "server/services/aiDedupScheduler.js"
      provides: "Review flag preservation in runAIRededup merge logic"
      contains: "existingMap"
    - path: "server/controllers/adminClientCreditorController.js"
      provides: "Review flag preservation in admin triggerAIReDedup"
      contains: "existingMap"
  key_links:
    - from: "server/services/aiDedupScheduler.js"
      to: "server/models/Client.js"
      via: "final_creditor_list assignment with preserved fields"
      pattern: "needs_manual_review.*existing"
    - from: "server/controllers/adminClientCreditorController.js"
      to: "server/models/Client.js"
      via: "final_creditor_list assignment with preserved fields"
      pattern: "needs_manual_review.*existing"
---

<objective>
Preserve manual review flags (needs_manual_review, review_reasons, manually_reviewed, reviewed_at, reviewed_by, review_action, original_ai_data, correction_notes) when dedup overwrites final_creditor_list. Both the scheduler dedup path and the admin-triggered dedup path must preserve these fields.

Purpose: Ensures creditors flagged for manual review don't lose their flags when dedup re-merges the list (DAT-01). Without this, dedup would reset needs_manual_review to false, causing the payment handler to auto-approve cases that should go through agent review.
Output: Modified merge logic in both aiDedupScheduler.js and adminClientCreditorController.js that builds a lookup map of existing creditors and preserves their review state during overwrite.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-deduplication-timing-data-integrity/01-CONTEXT.md
@.planning/phases/01-deduplication-timing-data-integrity/01-RESEARCH.md

Key source files to read before editing:
@server/services/aiDedupScheduler.js
@server/controllers/adminClientCreditorController.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Preserve review flags in aiDedupScheduler.js runAIRededup</name>
  <files>server/services/aiDedupScheduler.js</files>
  <action>
In the `runAIRededup` function, find the section where `client.final_creditor_list` is overwritten (around lines 231-239). The current code is:

```javascript
client.final_creditor_list = deduplicated_creditors.map(c => ({
  ...c,
  id: c.id || uuidv4(),
  status: c.status || 'confirmed',
  ai_confidence: c.ai_confidence || 1.0,
  created_at: c.created_at || new Date(),
  needs_manual_review: c.needs_manual_review || false,
  review_reasons: c.review_reasons || []
}));
```

Replace it with review-flag-preserving merge logic:

```javascript
// Build lookup map of existing creditors for O(1) field preservation
const existingMap = new Map();
for (const existing of (client.final_creditor_list || [])) {
  if (existing.id) {
    existingMap.set(existing.id, existing);
  }
  // Also index by normalized name for creditors whose IDs changed during dedup
  const name = (existing.sender_name || existing.glaeubiger_name || '').toLowerCase().trim();
  if (name && !existingMap.has(`name:${name}`)) {
    existingMap.set(`name:${name}`, existing);
  }
}

client.final_creditor_list = deduplicated_creditors.map(c => {
  // Find existing creditor by ID first, then by name
  const existingById = existingMap.get(c.id);
  const name = (c.sender_name || c.glaeubiger_name || '').toLowerCase().trim();
  const existingByName = name ? existingMap.get(`name:${name}`) : null;
  const existing = existingById || existingByName;

  return {
    ...c,
    id: c.id || uuidv4(),
    status: c.status || 'confirmed',
    ai_confidence: c.ai_confidence || 1.0,
    created_at: existing?.created_at || c.created_at || new Date(),

    // PRESERVE manual review state from existing creditor
    // Use existing values if they indicate review is needed, otherwise use dedup values
    needs_manual_review: existing?.needs_manual_review || c.needs_manual_review || false,
    review_reasons: mergeReviewReasons(existing?.review_reasons, c.review_reasons),
    manually_reviewed: existing?.manually_reviewed || false,
    reviewed_at: existing?.reviewed_at,
    reviewed_by: existing?.reviewed_by,
    review_action: existing?.review_action,
    original_ai_data: existing?.original_ai_data,
    correction_notes: existing?.correction_notes,
  };
});
```

Add the `mergeReviewReasons` helper function above `runAIRededup` (or near the top of the file, after the existing helper functions):

```javascript
/**
 * Merge review reasons from existing and new creditor data.
 * Preserves all existing reasons and adds any new ones without duplicates.
 */
function mergeReviewReasons(existingReasons, newReasons) {
  const existing = Array.isArray(existingReasons) ? existingReasons : [];
  const incoming = Array.isArray(newReasons) ? newReasons : [];
  const merged = [...existing];
  for (const reason of incoming) {
    if (reason && !merged.includes(reason)) {
      merged.push(reason);
    }
  }
  return merged;
}
```

**Key design decisions:**
- Use OR (`||`) for `needs_manual_review` so that if EITHER existing or dedup says review is needed, it stays needed. A creditor should never lose its manual review flag through dedup.
- Merge review_reasons arrays (union) rather than replacing — both existing reasons (e.g., "Fehlende Gläubiger-E-Mail") and new reasons from dedup enrichment checks should be preserved.
- Look up existing creditors by both ID and normalized name, because FastAPI dedup may reassign IDs during merge.
- Preserve `created_at` from existing creditor to maintain provenance.
  </action>
  <verify>
1. Read `server/services/aiDedupScheduler.js` and confirm:
   - `existingMap` is built from `client.final_creditor_list` before overwrite
   - `needs_manual_review` uses `existing?.needs_manual_review || c.needs_manual_review`
   - `review_reasons` calls `mergeReviewReasons`
   - `manually_reviewed`, `reviewed_at`, `reviewed_by`, `review_action`, `original_ai_data`, `correction_notes` are all preserved from existing
2. `mergeReviewReasons` function exists and correctly merges arrays without duplicates
3. Run `node -e "require('./server/services/aiDedupScheduler')"` — no syntax errors
  </verify>
  <done>
When runAIRededup overwrites final_creditor_list, it first builds a map of existing creditors and preserves all manual review state (needs_manual_review, review_reasons, manually_reviewed, reviewed_at, reviewed_by, review_action, original_ai_data, correction_notes). Review reasons are merged (union), and needs_manual_review is OR'd so it can never be lost.
  </done>
</task>

<task type="auto">
  <name>Task 2: Preserve review flags in admin-triggered dedup (adminClientCreditorController.js)</name>
  <files>server/controllers/adminClientCreditorController.js</files>
  <action>
In the `triggerAIReDedup` handler, find the section where `client.final_creditor_list` is overwritten (around line 747). The current code is:

```javascript
client.final_creditor_list = processedCreditors;
```

Where `processedCreditors` is built from `deduplicated_creditors.map(creditor => { ... })` (around lines 722-743) without preserving existing review state.

Apply the same preservation pattern. Before the `processedCreditors` mapping (around line 722), add the lookup map:

```javascript
// Build lookup map of existing creditors for review flag preservation
const existingMap = new Map();
for (const existing of (client.final_creditor_list || [])) {
  if (existing.id) {
    existingMap.set(existing.id, existing);
  }
  const name = (existing.sender_name || existing.glaeubiger_name || '').toLowerCase().trim();
  if (name && !existingMap.has(`name:${name}`)) {
    existingMap.set(`name:${name}`, existing);
  }
}
```

Then modify the `processedCreditors` mapping to preserve review fields. Find the existing mapping (around lines 722-743) and update it:

```javascript
const processedCreditors = deduplicated_creditors.map(creditor => {
  if (!creditor.id) {
    creditor.id = uuidv4();
    console.log(`Generated new ID for merged creditor: ${creditor.sender_name}`);
  }

  // Find existing creditor for field preservation
  const existingById = existingMap.get(creditor.id);
  const name = (creditor.sender_name || creditor.glaeubiger_name || '').toLowerCase().trim();
  const existingByName = name ? existingMap.get(`name:${name}`) : null;
  const existing = existingById || existingByName;

  // Merge review reasons (union of existing and new)
  const existingReasons = Array.isArray(existing?.review_reasons) ? existing.review_reasons : [];
  const newReasons = Array.isArray(creditor.review_reasons) ? creditor.review_reasons : [];
  const mergedReasons = [...existingReasons];
  for (const reason of newReasons) {
    if (reason && !mergedReasons.includes(reason)) {
      mergedReasons.push(reason);
    }
  }

  return {
    ...creditor,
    id: creditor.id,
    status: creditor.status || 'confirmed',
    ai_confidence: creditor.ai_confidence || 1.0,
    created_at: existing?.created_at || creditor.created_at || new Date(),
    needs_manual_review: existing?.needs_manual_review || creditor.needs_manual_review || false,
    review_reasons: mergedReasons,
    manually_reviewed: existing?.manually_reviewed || false,
    reviewed_at: existing?.reviewed_at,
    reviewed_by: existing?.reviewed_by,
    review_action: existing?.review_action,
    original_ai_data: existing?.original_ai_data,
    correction_notes: existing?.correction_notes,
  };
});
```

This ensures the admin "Trigger AI Re-Dedup" button also preserves all review state, exactly matching the scheduler behavior.
  </action>
  <verify>
1. Read `server/controllers/adminClientCreditorController.js` and confirm:
   - `existingMap` is built before the `processedCreditors` mapping
   - `needs_manual_review` uses `existing?.needs_manual_review || creditor.needs_manual_review`
   - `review_reasons` are merged (union)
   - `manually_reviewed`, `reviewed_at`, `reviewed_by`, `review_action`, `original_ai_data`, `correction_notes` preserved
2. Run `node -e "require('./server/controllers/adminClientCreditorController')"` — no syntax errors
  </verify>
  <done>
Admin-triggered dedup preserves all manual review state using the same pattern as the scheduler. The existing creditor lookup map matches by both ID and normalized name. Review reasons are union-merged and needs_manual_review is OR'd.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Scheduler preserves flags:** Read aiDedupScheduler.js — `existingMap` built, review fields preserved with OR logic
2. **Admin preserves flags:** Read adminClientCreditorController.js — same pattern applied
3. **Review reasons merged:** Both files merge review_reasons arrays without duplicates
4. **No regression:** `needs_manual_review: false` still works — if neither existing nor dedup sets it, it remains false
5. **Name-based fallback:** Both files look up existing creditors by name when ID doesn't match (covers FastAPI ID reassignment)
6. **No import errors:** Both files can be required without errors
</verification>

<success_criteria>
- Creditors with needs_manual_review=true keep that flag after both scheduler dedup and admin dedup
- review_reasons arrays are union-merged (no reasons lost, no duplicates)
- manually_reviewed, reviewed_at, reviewed_by, review_action, original_ai_data, correction_notes all survive dedup
- Creditors without manual review flags still work correctly (needs_manual_review remains false)
- Existing creditors are matched by both ID and normalized name for robustness
</success_criteria>

<output>
After completion, create `.planning/phases/01-deduplication-timing-data-integrity/01-02-SUMMARY.md`
</output>
