---
phase: 01-deduplication-timing-data-integrity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/services/aiDedupScheduler.js
  - server/controllers/webhookController.js
  - server/models/Client.js
  - server/server.js
  - server/routes/webhooks.js
autonomous: true

must_haves:
  truths:
    - "Dedup triggers within seconds of the last document finishing processing, not 30 minutes later"
    - "No 30-minute setTimeout delay exists in the dedup scheduler"
    - "Double-trigger is prevented via atomic MongoDB dedup_in_progress flag"
    - "Pending 30-minute jobs are cancelled when immediate dedup runs"
  artifacts:
    - path: "server/services/aiDedupScheduler.js"
      provides: "Immediate dedup execution with atomic dedup_in_progress guard"
      contains: "dedup_in_progress"
    - path: "server/controllers/webhookController.js"
      provides: "Dedup trigger on allDocsCompleted"
      contains: "scheduleAIRededup"
    - path: "server/models/Client.js"
      provides: "dedup_in_progress schema field"
      contains: "dedup_in_progress"
  key_links:
    - from: "server/controllers/webhookController.js"
      to: "server/services/aiDedupScheduler.js"
      via: "scheduleAIRededup call when allDocsCompleted"
      pattern: "scheduleAIRededup"
    - from: "server/services/aiDedupScheduler.js"
      to: "server/models/Client.js"
      via: "atomic dedup_in_progress flag set/clear"
      pattern: "dedup_in_progress"
---

<objective>
Convert dedup scheduler from 30-minute delayed execution to immediate event-driven execution, triggered when all documents finish processing. Add atomic dedup-in-progress flag to prevent double-trigger race conditions.

Purpose: Eliminates the 30-minute gap between document processing completion and dedup execution (DDP-01, DDP-03). Provides the `dedup_in_progress` flag that Plan 01-03 uses for payment-dedup coordination.
Output: Modified aiDedupScheduler.js running dedup immediately, webhookController.js triggering dedup on allDocsCompleted, Client.js schema with dedup_in_progress field.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-deduplication-timing-data-integrity/01-CONTEXT.md
@.planning/phases/01-deduplication-timing-data-integrity/01-RESEARCH.md

Key source files to read before editing:
@server/services/aiDedupScheduler.js
@server/controllers/webhookController.js
@server/models/Client.js
@server/server.js
@server/routes/webhooks.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dedup coordination fields to Client schema and convert scheduler to immediate execution</name>
  <files>
    server/models/Client.js
    server/services/aiDedupScheduler.js
  </files>
  <action>
**Client.js — Add dedup coordination fields:**

Near the existing `all_documents_processed_at: Date` field (around line 312), add:

```javascript
dedup_in_progress: { type: Boolean, default: false },
dedup_started_at: Date,
dedup_completed_at: Date,
```

These fields enable atomic dedup-in-progress guarding and payment handler coordination.

**aiDedupScheduler.js — Convert to immediate execution with atomic guard:**

1. Remove the `DEDUP_DELAY_MS` constant (line 17: `const DEDUP_DELAY_MS = 30 * 60 * 1000;`).

2. Replace the `scheduleAIRededup` function (lines 35-64) to run dedup IMMEDIATELY instead of scheduling a 30-minute timeout:

```javascript
async function scheduleAIRededup(clientId, getClientFunction) {
  if (!clientId) {
    console.error('[ai-dedup-scheduler] Cannot schedule - clientId is required');
    return;
  }
  if (typeof getClientFunction !== 'function') {
    console.error('[ai-dedup-scheduler] Cannot schedule - getClientFunction must be a function');
    return;
  }

  console.log(`[ai-dedup-scheduler] Running immediate dedup for client ${clientId}...`);

  // Cancel any pending delayed job (legacy cleanup)
  if (pendingJobs.has(clientId)) {
    clearTimeout(pendingJobs.get(clientId));
    pendingJobs.delete(clientId);
    console.log(`[ai-dedup-scheduler] Cancelled pending delayed job for ${clientId}`);
  }

  // Run dedup IMMEDIATELY (no 30-minute delay)
  return runAIRededup(clientId, getClientFunction);
}
```

Note: `scheduleAIRededup` now returns a Promise (it was fire-and-forget before). This is intentional — callers can optionally await the result.

3. In the `runAIRededup` function, add atomic dedup-in-progress guard at the start (after `const client = await getClientFunction(clientId)` succeeds, around line 78):

```javascript
// Atomic guard: prevent double-execution via MongoDB atomic update
const Client = require('../models/Client');
const guardResult = await Client.updateOne(
  { _id: client._id, dedup_in_progress: { $ne: true } },
  { $set: { dedup_in_progress: true, dedup_started_at: new Date() } }
);

if (guardResult.modifiedCount === 0) {
  console.log(`[ai-dedup-scheduler] Dedup already in progress for ${clientId}, skipping`);
  return { success: false, reason: 'dedup_already_in_progress' };
}
```

4. Wrap the main dedup logic in a try/finally block that ALWAYS clears the flag:

In the existing try block (line 74), after the guard check, keep the existing logic. Then modify the existing catch block and add a finally block:

```javascript
} catch (error) {
  // ... existing error handling ...
} finally {
  // ALWAYS clear dedup_in_progress flag
  try {
    await Client.updateOne(
      { _id: client._id },
      { $set: { dedup_in_progress: false, dedup_completed_at: new Date() } }
    );
  } catch (clearError) {
    console.error(`[ai-dedup-scheduler] Failed to clear dedup_in_progress for ${clientId}:`, clearError.message);
  }
}
```

5. In the dedup history push (line 247), update the method to `'immediate-ai-rededup'` instead of `'periodic-ai-rededup'`:

```javascript
method: 'immediate-ai-rededup',
```

IMPORTANT: The `Client` model needs to be required at the top of `aiDedupScheduler.js`. Add `const Client = require('../models/Client');` near the existing requires at the top of the file (after line 11).
  </action>
  <verify>
1. Read `server/models/Client.js` and confirm `dedup_in_progress`, `dedup_started_at`, `dedup_completed_at` fields exist
2. Read `server/services/aiDedupScheduler.js` and confirm:
   - No `DEDUP_DELAY_MS` constant
   - No `setTimeout` in `scheduleAIRededup`
   - `Client.updateOne` atomic guard at start of `runAIRededup`
   - `finally` block clearing `dedup_in_progress`
   - Method changed to `'immediate-ai-rededup'`
3. Run `node -e "require('./server/services/aiDedupScheduler')"` from project root — no syntax/import errors
  </verify>
  <done>
Client schema has dedup coordination fields. Scheduler runs dedup immediately with no 30-minute delay. Atomic dedup_in_progress guard prevents double-execution. Flag is always cleared in finally block.
  </done>
</task>

<task type="auto">
  <name>Task 2: Trigger dedup from document processing completion in webhookController</name>
  <files>
    server/controllers/webhookController.js
    server/server.js
    server/routes/webhooks.js
  </files>
  <action>
**webhookController.js — Add aiDedupScheduler dependency and trigger dedup on allDocsCompleted:**

1. Update the `createWebhookController` factory function signature (line 240) to accept `aiDedupScheduler`:

```javascript
const createWebhookController = ({ Client, safeClientUpdate, getClient, triggerProcessingCompleteWebhook, getIO, aiDedupScheduler }) => {
```

2. Find the `allDocsCompleted` check block (around lines 596-622). After the existing `documents_completed` status is set and the status history entry is pushed (after line 618), add the dedup trigger:

```javascript
// Trigger immediate AI deduplication after all documents processed
if (creditorDocs.length > 0) {
  console.log(`[webhook] All ${totalDocs} documents processed. Triggering immediate AI dedup for ${client_id}...`);
  // Set all_documents_processed_at timestamp
  clientDoc.all_documents_processed_at = new Date();
  // Fire dedup asynchronously — don't block webhook response
  setImmediate(async () => {
    try {
      await aiDedupScheduler.scheduleAIRededup(client_id, getClient);
      console.log(`[webhook] AI dedup completed for ${client_id}`);
    } catch (err) {
      console.error(`[webhook] AI dedup failed for ${client_id}:`, err.message);
    }
  });
}
```

Place this code inside the `if (allDocsCompleted)` block, inside the `if (creditorDocs.length > 0)` branch, AFTER the status history push but BEFORE the closing braces. The `setImmediate` ensures the dedup runs asynchronously without blocking the webhook response or the `clientDoc.save()` that follows.

**server.js — Pass aiDedupScheduler to webhook controller:**

Find the webhook controller creation (around line 269-275):

```javascript
const webhookController = createWebhookController({
  Client,
  safeClientUpdate: clientService.safeClientUpdate.bind(clientService),
  getClient: clientService.getClient.bind(clientService),
  triggerProcessingCompleteWebhook,
  getIO
});
```

Add `aiDedupScheduler` to the dependencies:

```javascript
const webhookController = createWebhookController({
  Client,
  safeClientUpdate: clientService.safeClientUpdate.bind(clientService),
  getClient: clientService.getClient.bind(clientService),
  triggerProcessingCompleteWebhook,
  getIO,
  aiDedupScheduler
});
```

**routes/webhooks.js — No changes needed.** The webhook routes file already receives and passes `webhookController` to the router. Since we're modifying the controller factory, the route file doesn't need changes. The `aiDedupScheduler` import on line 7 is also already there but unused — it can be left as-is or removed (prefer leaving for now).
  </action>
  <verify>
1. Read `server/controllers/webhookController.js` line 240 — confirm `aiDedupScheduler` is in the destructured params
2. Grep for `scheduleAIRededup` in `webhookController.js` — confirm it's called in the allDocsCompleted block
3. Read `server/server.js` around line 269 — confirm `aiDedupScheduler` is passed to `createWebhookController`
4. Run `node -e "require('./server/controllers/webhookController')"` from project root — no syntax errors
  </verify>
  <done>
When all documents finish processing and creditor documents exist, dedup triggers immediately via scheduleAIRededup. The trigger is asynchronous (setImmediate) so it doesn't block the webhook response. The aiDedupScheduler dependency is properly injected through the existing factory pattern.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **No 30-minute delay exists:** Grep for `DEDUP_DELAY_MS` and `30 * 60` in aiDedupScheduler.js — should find nothing
2. **Immediate trigger wired:** Grep for `scheduleAIRededup` in webhookController.js — should find the call in allDocsCompleted block
3. **Atomic guard present:** Grep for `dedup_in_progress` in aiDedupScheduler.js — should find updateOne atomic check
4. **Schema updated:** Grep for `dedup_in_progress` in Client.js — should find the field
5. **Dependency injected:** Grep for `aiDedupScheduler` in server.js createWebhookController call — should find it
6. **No import errors:** `node -e "require('./server/services/aiDedupScheduler'); require('./server/controllers/webhookController')"` exits cleanly
</verification>

<success_criteria>
- aiDedupScheduler.scheduleAIRededup runs dedup immediately (no setTimeout, no 30-min delay)
- webhookController triggers scheduleAIRededup when allDocsCompleted is true and creditor docs exist
- MongoDB atomic dedup_in_progress flag prevents concurrent dedup execution
- Client schema includes dedup_in_progress, dedup_started_at, dedup_completed_at fields
- all_documents_processed_at is set when all docs complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-deduplication-timing-data-integrity/01-01-SUMMARY.md`
</output>
