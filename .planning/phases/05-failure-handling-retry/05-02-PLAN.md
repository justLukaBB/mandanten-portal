---
phase: 05-failure-handling-retry
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - server/services/aiDedupScheduler.js
autonomous: true

must_haves:
  truths:
    - "Dedup retries once on LLM failure before falling back (FAIL-01)"
    - "Cases flag for manual review if retry fails — no silent duplicate pass-through (FAIL-02)"
    - "Failures logged with creditor count, error message, and attempt number (FAIL-03)"
    - "Creditors pass through unmerged on failure — pipeline continues"
    - "dedup_failure_reason is stored on the case with human-readable explanation"
  artifacts:
    - path: "server/services/aiDedupScheduler.js"
      provides: "Retry-wrapped FastAPI call with manual review flagging on failure"
      contains: "retryWithDelay"
  key_links:
    - from: "server/services/aiDedupScheduler.js (runAIRededup catch block)"
      to: "Client.updateOne (manual review flag)"
      via: "MongoDB atomic update setting needs_manual_review and dedup_failure_reason"
      pattern: "dedup_failure_reason.*failed after"
    - from: "server/services/aiDedupScheduler.js (axios.post)"
      to: "retryWithDelay wrapper"
      via: "FastAPI call wrapped in retry loop"
      pattern: "retryWithDelay.*axios\\.post"
---

<objective>
Wire the retry wrapper into the live dedup flow and add manual review flagging when all retry attempts fail. On failure: creditors pass through unmerged, case is flagged for manual review with a failure reason, and the pipeline continues.

Purpose: Complete FAIL-01 (retry once), FAIL-02 (flag for manual review, no silent pass-through), and FAIL-03 (structured failure logging). This is the integration plan that makes retry + flagging live.

Output: `runAIRededup()` uses `retryWithDelay()` for the FastAPI call. On failure after retry, sets `needs_manual_review=true` and `dedup_failure_reason` on the case via atomic update. Creditors pass through unmerged.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-failure-handling-retry/05-CONTEXT.md
@.planning/phases/05-failure-handling-retry/05-RESEARCH.md
@.planning/phases/05-failure-handling-retry/05-01-SUMMARY.md
@server/services/aiDedupScheduler.js
@server/models/Client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap FastAPI call in retryWithDelay and add manual review flagging</name>
  <files>server/services/aiDedupScheduler.js</files>
  <action>
Modify the `runAIRededup()` function in server/services/aiDedupScheduler.js to wrap the FastAPI axios call in the `retryWithDelay()` helper (added in Plan 01) and add manual review flagging in the catch block.

**Step 1: Wrap the axios.post call in retryWithDelay**

Replace the direct axios.post call (around lines 114-125) with a retryWithDelay wrapper. The current code is:

```javascript
const response = await axios.post(
  `${FASTAPI_URL}/api/dedup/deduplicate-all`,
  { creditors: creditorList },
  {
    headers: {
      'Content-Type': 'application/json',
      'X-API-Key': FASTAPI_API_KEY
    },
    timeout: 60000 // Changed in Plan 01
  }
);
```

Replace with:

```javascript
const response = await retryWithDelay(
  async (attempt) => {
    console.log(`[ai-dedup-scheduler] Dedup attempt ${attempt} for ${clientId} (${creditorList.length} creditors)...`);
    return await axios.post(
      `${FASTAPI_URL}/api/dedup/deduplicate-all`,
      { creditors: creditorList },
      {
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': FASTAPI_API_KEY
        },
        timeout: 60000
      }
    );
  },
  { maxAttempts: 2, delayMs: 2000 }
);
```

Key points:
- 2 total attempts (1 initial + 1 retry) per context decision
- 2-second delay between attempts per context decision
- Attempt number logged in each call per FAIL-03
- Creditor count included in the log per FAIL-03

**Step 2: Add manual review flagging in the catch block**

Replace the existing catch block (around lines 323-338) which currently just logs and returns `{ success: false, error: error.message }`. The new catch block must:

1. Log the final failure with structured data (creditor count, error message, attempt count) — FAIL-03
2. Set case-level manual review flag via atomic MongoDB update — FAIL-02
3. Store failure reason in `dedup_failure_reason` — context decision
4. NOT modify `final_creditor_list` — creditors pass through unmerged — context decision
5. Return a result indicating manual review was flagged

Replace the catch block with:

```javascript
  } catch (error) {
    // FAIL-03: Log failure with creditor count, error, and attempt number
    console.error(`[ai-dedup-scheduler] ❌ AI re-dedup failed for ${clientId} after all retry attempts:`, {
      creditor_count: creditorList.length,
      error_message: error.message,
      attempts_exhausted: 2,
      status: error.response?.status || 'no_response',
      timestamp: new Date().toISOString()
    });

    if (error.response) {
      console.error(`[ai-dedup-scheduler] FastAPI error response:`, {
        status: error.response.status,
        data: error.response.data
      });
    }

    // FAIL-02: Flag case for manual review — no silent duplicate pass-through
    // Creditors pass through UNMERGED (final_creditor_list unchanged)
    // Use atomic update to avoid race conditions with other operations
    const failureReason = `AI deduplication failed after 2 attempts: ${error.message}`;
    try {
      await Client.updateOne(
        { _id: client._id },
        {
          $set: {
            needs_manual_review: true,
            dedup_failure_reason: failureReason
          }
        }
      );
      console.log(`[ai-dedup-scheduler] ⚠️ Flagged ${clientId} for manual review: ${failureReason}`);
    } catch (flagError) {
      console.error(`[ai-dedup-scheduler] Failed to flag ${clientId} for manual review:`, flagError.message);
    }

    // Return error result — pipeline continues with unmerged creditors
    return {
      success: false,
      error: error.message,
      manual_review_flagged: true,
      failure_reason: failureReason
    };
  }
```

Key design choices:
- Uses `Client.updateOne` atomic update (NOT `client.save()`) to avoid race conditions — matches existing pattern from the dedup guard (line 94-97)
- Sets `needs_manual_review: true` at CASE level (NOT individual creditors) — per context decision
- Does NOT touch `final_creditor_list` — creditors pass through unmerged — per context decision
- Wraps the flagging in try/catch so a flagging failure doesn't hide the original error
- Returns `manual_review_flagged: true` so callers know the case was flagged
- `failureReason` is human-readable for admin review

**Important:** The `client` variable is declared inside `runAIRededup` at line 86. Make sure the catch block can access it. Currently the catch block is at the same scope level as the try block that declares `client`, so it IS accessible. However, if the error happens BEFORE `client` is fetched (e.g., getClientFunction fails), `client` would be undefined. Add a guard:

Before the `Client.updateOne` call in the catch block, check:
```javascript
if (client && client._id) {
  // ... atomic update ...
}
```

This handles the edge case where the error occurs before client is loaded.

**Note on `needs_manual_review` at case level:** The Client schema does NOT currently have a top-level `needs_manual_review` field — only creditors have it. For the atomic update, we need to use the `$set` operator which will create the field dynamically on the document even if not in the schema (Mongoose strict mode may block this).

Instead of a case-level `needs_manual_review` boolean, the `dedup_failure_reason` field (added in Plan 01) IS the signal. If `dedup_failure_reason` is set (non-null/non-empty), the case needs manual review due to dedup failure. The existing payment handler already checks creditor-level `needs_manual_review` flags. For case-level dedup failure, set `dedup_failure_reason` only — this is sufficient for admins to identify failed cases.

So the atomic update becomes:
```javascript
await Client.updateOne(
  { _id: client._id },
  {
    $set: {
      dedup_failure_reason: failureReason
    }
  }
);
```

The `dedup_failure_reason` field (String, added in Plan 01) is the case-level signal. Admins can query `{ dedup_failure_reason: { $exists: true, $ne: null } }` to find failed cases. This is cleaner than adding a redundant boolean.
  </action>
  <verify>
Run: `grep -n "retryWithDelay" server/services/aiDedupScheduler.js` — should show the wrapper usage in runAIRededup
Run: `grep -n "dedup_failure_reason" server/services/aiDedupScheduler.js` — should show it being set in catch block
Run: `grep -n "attempts_exhausted" server/services/aiDedupScheduler.js` — should show structured failure logging
Run: `grep -c "manual_review_flagged" server/services/aiDedupScheduler.js` — should return 1 (in return object)
Run: `node -e "require('./server/services/aiDedupScheduler'); console.log('OK')"` — should print OK
  </verify>
  <done>
FastAPI call is wrapped in retryWithDelay (2 attempts, 2s delay). On failure after retry: dedup_failure_reason is set on case via atomic update, creditors pass through unmerged, structured log includes creditor count + error + attempt number. Module loads without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify end-to-end retry and flagging flow</name>
  <files>server/services/aiDedupScheduler.js</files>
  <action>
Verify the complete retry + flagging flow by reading the final state of `runAIRededup()` and confirming:

1. **FAIL-01 check:** The axios.post call is inside `retryWithDelay()` with `maxAttempts: 2`. This means on first failure, it waits 2 seconds, then retries once. Only after the second failure does it throw to the catch block.

2. **FAIL-02 check:** The catch block sets `dedup_failure_reason` on the case via `Client.updateOne`. It does NOT modify `final_creditor_list` (creditors pass through unmerged). The function returns `{ success: false, manual_review_flagged: true }` so callers know.

3. **FAIL-03 check:** Inside `retryWithDelay`, each attempt logs `attempt_number` and `max_attempts`. In the catch block, the final failure log includes `creditor_count`, `error_message`, and `attempts_exhausted`.

4. **Timeout check:** The axios call uses `timeout: 60000` (60 seconds), not the old 300000ms (5 minutes).

5. **Finally block check:** The existing `finally` block (lines 339-348) still clears `dedup_in_progress: false`. Confirm this was NOT accidentally removed or broken by the changes.

6. **Guard check:** The `client._id` guard prevents errors when client was not loaded.

If any of these checks fail, fix the issue. This is a read-verify-fix task, not a new implementation task.
  </action>
  <verify>
Read through the complete `runAIRededup` function and confirm all 6 checks above pass. The function should have this flow:

```
runAIRededup()
  → atomic guard (dedup_in_progress)
  → retryWithDelay(axios.post, {maxAttempts: 2, delayMs: 2000})
    → attempt 1: axios.post with 60s timeout
    → [if fails] log attempt 1, wait 2s
    → attempt 2: axios.post with 60s timeout
    → [if fails] log attempt 2, throw
  → [success] process deduplicated creditors (existing logic)
  → [failure catch] log with creditor_count/error/attempts, set dedup_failure_reason, return flagged result
  → [finally] clear dedup_in_progress
```
  </verify>
  <done>
All 6 verification checks pass. The retry flow is: attempt 1 -> wait 2s -> attempt 2 -> flag for manual review. Creditors pass through unmerged. Finally block clears dedup_in_progress. All three FAIL requirements are satisfied.
  </done>
</task>

</tasks>

<verification>
1. `retryWithDelay` wraps the axios.post call in runAIRededup — `grep "retryWithDelay" server/services/aiDedupScheduler.js`
2. `dedup_failure_reason` is set in catch block — `grep "dedup_failure_reason" server/services/aiDedupScheduler.js`
3. Structured logging includes creditor_count, error_message, attempts_exhausted — `grep "attempts_exhausted\|creditor_count\|attempt_number" server/services/aiDedupScheduler.js`
4. Timeout is 60000ms — `grep "timeout: 60000" server/services/aiDedupScheduler.js`
5. No 300000ms timeout remains — `grep -c "timeout: 300000" server/services/aiDedupScheduler.js` returns 0
6. finally block still clears dedup_in_progress — `grep "dedup_in_progress: false" server/services/aiDedupScheduler.js`
7. Module loads — `node -e "require('./server/services/aiDedupScheduler'); console.log('OK')"`
8. Return object includes manual_review_flagged — `grep "manual_review_flagged" server/services/aiDedupScheduler.js`
</verification>

<success_criteria>
- FAIL-01: FastAPI call retries once (2 total attempts) with 2-second delay before falling back
- FAIL-02: On failure after retry, dedup_failure_reason is set on the case, creditors pass through unmerged, no silent duplicate pass-through
- FAIL-03: Every attempt logged with attempt number; final failure logged with creditor count, error message, and attempt count
- Pipeline continues after failure (runAIRededup returns result object, does not throw)
- Finally block still clears dedup_in_progress (no regression)
- Module loads without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-failure-handling-retry/05-02-SUMMARY.md`
</output>
